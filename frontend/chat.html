<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üí¨ Chat em Tempo Real - gRPC Microservices</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .chat-container {
            width: 100%;
            max-width: 800px;
            height: 90vh;
            background: white;
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }

        .chat-header h1 {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .chat-header p {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .user-info {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            font-size: 0.85rem;
            color: white;
        }

        .user-info strong {
            color: #fff;
        }

        .connection-status {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .status-connected {
            background: #4CAF50;
            color: white;
        }

        .status-disconnected {
            background: #f44336;
            color: white;
        }

        .status-connecting {
            background: #ff9800;
            color: white;
        }

        .login-form {
            padding: 40px;
            text-align: center;
        }

        .login-form h2 {
            color: #333;
            margin-bottom: 20px;
        }

        .login-form input {
            width: 100%;
            max-width: 300px;
            padding: 12px;
            font-size: 1rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            margin-bottom: 15px;
            outline: none;
            transition: border-color 0.3s;
        }

        .login-form input:focus {
            border-color: #667eea;
        }

        .login-form button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 30px;
            font-size: 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .login-form button:hover {
            transform: translateY(-2px);
        }

        .chat-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .users-online {
            background: #f8f9fa;
            padding: 15px;
            border-bottom: 1px solid #e9ecef;
            font-size: 0.9rem;
            color: #666;
        }

        .users-online strong {
            color: #333;
        }

        .messages-container {
            flex: 1;
            overflow-y: scroll;
            overflow-x: hidden;
            padding: 20px;
            background: #f8f9fa;
            scroll-behavior: smooth;
            max-height: calc(100vh - 300px);
        }

        .messages-container::-webkit-scrollbar {
            width: 8px;
        }

        .messages-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .messages-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }

        .messages-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .message {
            margin-bottom: 15px;
            animation: fadeInUp 0.3s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message-header {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
        }

        .message-content {
            background: white;
            padding: 12px 15px;
            border-radius: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            word-wrap: break-word;
        }

        .message.own .message-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin-left: 20%;
        }

        .message.system .message-content {
            background: #e3f2fd;
            color: #1976d2;
            font-style: italic;
            text-align: center;
        }

        .message.join .message-content {
            background: #e8f5e8;
            color: #2e7d32;
            text-align: center;
        }

        .message.leave .message-content {
            background: #fff3e0;
            color: #f57c00;
            text-align: center;
        }

        .input-container {
            padding: 20px;
            background: white;
            border-top: 1px solid #e9ecef;
            display: flex;
            gap: 10px;
        }

        .message-input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 25px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s;
        }

        .message-input:focus {
            border-color: #667eea;
        }

        .send-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            transition: transform 0.2s;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .send-button:hover:not(:disabled) {
            transform: scale(1.1);
        }

        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .typing-indicator {
            padding: 10px 20px;
            font-style: italic;
            color: #666;
            font-size: 0.9rem;
            background: #fff;
            border-top: 1px solid #e9ecef;
            min-height: 40px;
            display: flex;
            align-items: center;
        }

        .hidden {
            display: none;
        }

        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
        }

        .emoji-picker {
            display: inline-block;
            margin-left: 10px;
        }

        .emoji-picker button {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
        }

        .emoji-picker button:hover {
            background-color: #f0f0f0;
        }

        /* File Upload Styles */
        .file-upload-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .upload-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            transition: transform 0.2s;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .upload-button:hover:not(:disabled) {
            transform: scale(1.1);
        }

        .upload-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #fileInput {
            display: none;
        }

        .file-message {
            background: #f0f7ff;
            border: 1px solid #b3d9ff;
            border-radius: 10px;
            padding: 12px 15px;
            margin: 10px 0;
        }

        .file-message.own {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            margin-left: 20%;
        }

        .file-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .file-name {
            font-weight: bold;
            word-break: break-all;
            margin-bottom: 5px;
        }

        .file-size {
            font-size: 0.85rem;
            opacity: 0.8;
        }

        .file-progress {
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }

        .file-message.own .file-progress {
            background: rgba(255, 255, 255, 0.3);
        }

        .file-progress-bar {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s ease;
            width: 0%;
        }

        .file-message.own .file-progress-bar {
            background: #4CAF50;
        }

        .file-action {
            display: inline-block;
            padding: 6px 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85rem;
            margin-top: 8px;
        }

        .file-message.own .file-action {
            background: rgba(255, 255, 255, 0.3);
        }

        .file-action:hover {
            opacity: 0.8;
        }

        .upload-progress {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            border-radius: 10px;
            padding: 15px 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-width: 250px;
            z-index: 1000;
            display: none;
        }

        .upload-progress.visible {
            display: block;
        }

        .upload-progress-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .upload-progress-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .upload-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.2s ease;
        }

        .upload-progress-text {
            font-size: 0.8rem;
            color: #666;
        }

        @media (max-width: 600px) {
            .chat-container {
                height: 100vh;
                border-radius: 0;
                max-width: 100%;
            }

            .message.own .message-content {
                margin-left: 10%;
            }
        }

        /* Modal Styles para Preview */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            animation: fadeIn 0.3s ease;
        }

        .modal.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            max-width: 90%;
            max-height: 90vh;
            overflow: auto;
            display: flex;
            flex-direction: column;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            color: #333;
            font-size: 1.2rem;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }

        .modal-close:hover {
            color: #333;
        }

        .modal-body {
            padding: 20px;
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .modal-image {
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
            border-radius: 10px;
        }

        .modal-actions {
            padding: 15px 20px;
            border-top: 1px solid #e9ecef;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .modal-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
        }

        .modal-btn:hover {
            opacity: 0.9;
        }

        .modal-btn.secondary {
            background: #e9ecef;
            color: #333;
        }

        .image-thumbnail {
            max-width: 100%;
            max-height: 150px;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .image-thumbnail:hover {
            transform: scale(1.05);
        }
    </style>
</head>

<body>
    <div class="chat-container">
        <div class="chat-header">
            <h1>üí¨ Chat em Tempo Real</h1>
            <p>Sistema Distribu√≠do com gRPC e WebSocket</p>
            <div id="userInfo" class="user-info hidden">
                Logado como: <strong id="currentUsername"></strong>
            </div>
            <div id="connectionStatus" class="connection-status status-disconnected">
                Desconectado
            </div>

        </div>

        <!-- Tela de Login -->
        <div id="loginScreen" class="login-form">
            <h2>Entre no Chat</h2>
            <div id="loginError" class="error-message hidden"></div>
            <form id="loginForm">
                <input type="text" id="usernameInput" placeholder="Seu nome de usu√°rio" required maxlength="20"
                    autocomplete="off">
                <input type="text" id="roomInput" placeholder="Sala do chat (padr√£o: global)" value="global"
                    maxlength="20" autocomplete="off">
                <button type="submit">Entrar no Chat üöÄ</button>
            </form>
        </div>

        <!-- Interface do Chat -->
        <div id="chatInterface" class="hidden">
            <div class="chat-main">
                <div id="usersOnline" class="users-online">
                    <strong>Usu√°rios online:</strong> <span id="usersList">Carregando...</span>
                </div>

                <div id="messagesContainer" class="messages-container">
                    <!-- Mensagens aparecer√£o aqui -->
                </div>

                <div id="typingIndicator" class="typing-indicator hidden">
                    <span id="typingText">Algu√©m est√° digitando...</span>
                </div>

                <div class="input-container">
                    <input type="text" id="messageInput" class="message-input" placeholder="Digite sua mensagem..."
                        maxlength="500" autocomplete="off">
                    <input type="file" id="fileInput" accept="*/*">
                    <div class="emoji-picker">
                        <button type="button" onclick="addEmoji('üòÄ')">üòÄ</button>
                        <button type="button" onclick="addEmoji('üëç')">üëç</button>
                        <button type="button" onclick="addEmoji('‚ù§Ô∏è')">‚ù§Ô∏è</button>
                        <button type="button" onclick="addEmoji('üòÇ')">üòÇ</button>
                        <button type="button" onclick="addEmoji('üéâ')">üéâ</button>
                    </div>
                    <button id="uploadButton" class="upload-button" disabled title="üìé Upload de arquivo">
                        üìé
                    </button>
                    <button id="sendButton" class="send-button" disabled>
                        üì§
                    </button>
                </div>
            </div>
        </div>

        <!-- Upload Progress Indicator -->
        <div id="uploadProgress" class="upload-progress">
            <div class="upload-progress-title">Enviando arquivo...</div>
            <div class="upload-progress-bar">
                <div id="uploadProgressFill" class="upload-progress-fill"></div>
            </div>
            <div id="uploadProgressText" class="upload-progress-text">0%</div>
        </div>
    </div>

    <!-- Image Preview Modal -->
    <div id="previewModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Preview</h2>
                <button class="modal-close" onclick="window.chatApp.closePreviewModal()">‚úï</button>
            </div>
            <div class="modal-body">
                <img id="modalImage" class="modal-image" alt="Preview">
            </div>
            <div class="modal-actions">
                <button class="modal-btn" onclick="window.chatApp.downloadCurrentFile()">‚¨áÔ∏è Download</button>
                <button class="modal-btn secondary" onclick="window.chatApp.closePreviewModal()">Fechar</button>
            </div>
        </div>
    </div>

    <script>
        class ChatApp {
            constructor() {
                this.websocket = null;
                this.username = '';
                this.roomId = 'global';
                this.isConnected = false;
                this.typingTimer = null;
                this.isTyping = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.onlineUsers = new Set();
                this.uploadedFiles = new Map(); // Rastrear arquivos enviados
                this.fileStorage = new Map(); // Armazenar dados bin√°rios de arquivos {fileId: {blob, filename, mimeType}}
                this.inProgressUploads = {}; // Rastrear uploads em progresso {fileId: {chunks, metadata}}
                this.fileMetadata = {}; // Rastrear metadados de arquivos (username, room_id)
                this.currentPreviewFile = null; // Arquivo atualmente em preview

                this.initializeElements();
                this.bindEvents();
            }

            initializeElements() {
                // Elementos da tela de login
                this.loginScreen = document.getElementById('loginScreen');
                this.loginForm = document.getElementById('loginForm');
                this.usernameInput = document.getElementById('usernameInput');
                this.roomInput = document.getElementById('roomInput');
                this.loginError = document.getElementById('loginError');

                // Elementos da interface de chat
                this.chatInterface = document.getElementById('chatInterface');
                this.messagesContainer = document.getElementById('messagesContainer');
                this.messageInput = document.getElementById('messageInput');
                this.sendButton = document.getElementById('sendButton');
                this.fileInput = document.getElementById('fileInput');
                this.uploadButton = document.getElementById('uploadButton');
                this.uploadProgress = document.getElementById('uploadProgress');
                this.uploadProgressFill = document.getElementById('uploadProgressFill');
                this.uploadProgressText = document.getElementById('uploadProgressText');
                this.connectionStatus = document.getElementById('connectionStatus');
                this.usersOnline = document.getElementById('usersOnline');
                this.usersList = document.getElementById('usersList');
                this.typingIndicator = document.getElementById('typingIndicator');
                this.typingText = document.getElementById('typingText');
                this.userInfo = document.getElementById('userInfo');
                this.currentUsername = document.getElementById('currentUsername');

                // Elementos do modal de preview
                this.previewModal = document.getElementById('previewModal');
                this.modalImage = document.getElementById('modalImage');
                this.modalTitle = document.getElementById('modalTitle');
            }

            bindEvents() {
                // Eventos do formul√°rio de login
                this.loginForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleLogin();
                });

                // Eventos da interface de chat
                this.messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.sendMessage();
                    }
                });

                this.messageInput.addEventListener('input', () => {
                    this.handleTyping();
                });

                this.sendButton.addEventListener('click', () => {
                    this.sendMessage();
                });

                // Eventos de upload
                this.uploadButton.addEventListener('click', () => {
                    this.fileInput.click();
                });

                this.fileInput.addEventListener('change', () => {
                    this.handleFileSelect();
                });

                // Fechar modal ao clicar fora
                this.previewModal.addEventListener('click', (e) => {
                    if (e.target === this.previewModal) {
                        this.closePreviewModal();
                    }
                });

                // Fechar modal com tecla ESC
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.previewModal.classList.contains('visible')) {
                        this.closePreviewModal();
                    }
                });

                // Eventos de reconex√£o
                window.addEventListener('beforeunload', () => {
                    this.disconnect();
                });

                // Focus autom√°tico no campo de username
                this.usernameInput.focus();
            }

            async handleLogin() {
                const username = this.usernameInput.value.trim();
                const roomId = this.roomInput.value.trim() || 'global';

                if (!username) {
                    this.showLoginError('Por favor, digite um nome de usu√°rio');
                    return;
                }

                if (username.length < 2) {
                    this.showLoginError('Nome de usu√°rio deve ter pelo menos 2 caracteres');
                    return;
                }

                this.username = username;
                this.roomId = roomId;

                try {
                    await this.connectWebSocket();
                } catch (error) {
                    this.showLoginError('Erro ao conectar: ' + error.message);
                }
            }

            async connectWebSocket() {
                return new Promise((resolve, reject) => {
                    this.updateConnectionStatus('connecting');

                    const wsUrl = `ws://localhost:8000/ws/${this.roomId}?username=${encodeURIComponent(this.username)}`;
                    console.log('Conectando ao WebSocket:', wsUrl);

                    this.websocket = new WebSocket(wsUrl);

                    this.websocket.onopen = () => {
                        console.log('WebSocket conectado');
                        this.isConnected = true;
                        this.reconnectAttempts = 0;
                        this.updateConnectionStatus('connected');
                        this.switchToChat();
                        resolve();
                    };

                    this.websocket.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            this.handleIncomingMessage(message);
                        } catch (error) {
                            console.error('Erro ao processar mensagem:', error);
                        }
                    };

                    this.websocket.onclose = (event) => {
                        console.log('WebSocket desconectado:', event.code, event.reason);
                        this.isConnected = false;
                        this.updateConnectionStatus('disconnected');

                        if (event.code !== 1000 && this.reconnectAttempts < this.maxReconnectAttempts) {
                            this.attemptReconnect();
                        }
                    };

                    this.websocket.onerror = (error) => {
                        console.error('Erro no WebSocket:', error);
                        this.updateConnectionStatus('disconnected');
                        reject(new Error('Falha na conex√£o WebSocket'));
                    };

                    // Timeout para conex√£o
                    setTimeout(() => {
                        if (!this.isConnected) {
                            this.websocket.close();
                            reject(new Error('Timeout na conex√£o'));
                        }
                    }, 10000);
                });
            }

            attemptReconnect() {
                this.reconnectAttempts++;
                console.log(`Tentativa de reconex√£o ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);

                setTimeout(async () => {
                    try {
                        await this.connectWebSocket();
                    } catch (error) {
                        console.error('Falha na reconex√£o:', error);
                    }
                }, 2000 * this.reconnectAttempts);
            }

            switchToChat() {
                this.loginScreen.classList.add('hidden');
                this.chatInterface.classList.remove('hidden');
                this.messageInput.focus();
                this.uploadButton.disabled = false;

                // Mostrar informa√ß√µes do usu√°rio logado
                this.currentUsername.textContent = this.username;
                this.userInfo.classList.remove('hidden');
            }

            updateConnectionStatus(status) {
                this.connectionStatus.className = `connection-status status-${status}`;

                switch (status) {
                    case 'connected':
                        this.connectionStatus.textContent = 'üü¢ Conectado';
                        this.sendButton.disabled = false;
                        break;
                    case 'connecting':
                        this.connectionStatus.textContent = 'üü° Conectando...';
                        this.sendButton.disabled = true;
                        break;
                    case 'disconnected':
                        this.connectionStatus.textContent = 'üî¥ Desconectado';
                        this.sendButton.disabled = true;
                        break;
                }
            }

            handleIncomingMessage(message) {
                console.log('Mensagem recebida:', message);

                switch (message.type) {
                    case 'MESSAGE':
                        const isOwnMessage = message.username === this.username;
                        this.displayMessage(message, isOwnMessage);
                        break;
                    case 'FILE_SHARE':
                        // Armazenar informa√ß√µes do arquivo para recuperar depois dos chunks
                        if (!this.fileMetadata) {
                            this.fileMetadata = {};
                        }
                        this.fileMetadata[message.file_id] = {
                            username: message.username,
                            room_id: message.room_id || this.roomId,
                            timestamp: message.timestamp
                        };

                        // Se a mensagem j√° vem com file_data_b64 (recuperada do Module B), processar diretamente
                        if (message.file_data_b64) {
                            console.log(`üì• Arquivo recuperado do Module B: ${message.filename}`);

                            // Armazenar os dados do arquivo
                            this.storeFileData(message.file_id, message.file_data_b64, message.filename, message.mime_type);

                            // Exibir a mensagem do arquivo
                            const isOwnFile = message.username === this.username;
                            this.displayFileMessage(message, isOwnFile);
                        } else {
                            // Se for imagem, n√£o exibir aqui (ser√° exibida quando chunks chegarem)
                            // Se for outro arquivo, exibir normalmente
                            if (!this.isImageFile(message.filename, message.mime_type)) {
                                const isOwnFile = message.username === this.username;
                                this.displayFileMessage(message, isOwnFile);
                            }
                        }
                        break;
                    case 'FILE_CHUNK':
                        this.handleFileChunk(message);
                        break;
                    case 'USER_JOIN':
                        this.handleUserJoin(message);
                        break;
                    case 'USER_LEAVE':
                        this.handleUserLeave(message);
                        break;
                    case 'TYPING_START':
                        this.handleTypingStart(message);
                        break;
                    case 'TYPING_STOP':
                        this.handleTypingStop(message);
                        break;
                    case 'ONLINE_USERS':
                        this.updateOnlineUsers(message.users);
                        break;
                    case 'SYSTEM':
                        this.displaySystemMessage(message);
                        break;
                    default:
                        this.displayMessage(message);
                }
            }

            handleFileChunk(message) {
                const { file_id, filename, mime_type, file_size, chunk_index, total_chunks, chunk_data } = message;

                // Inicializar estrutura para arquivo se n√£o existir
                if (!this.inProgressUploads) {
                    this.inProgressUploads = {};
                }

                if (!this.inProgressUploads[file_id]) {
                    this.inProgressUploads[file_id] = {
                        chunks: {},
                        filename: filename,
                        mime_type: mime_type,
                        file_size: file_size,
                        total_chunks: total_chunks,
                        receivedChunks: 0,
                        startTime: Date.now()
                    };
                }

                const upload = this.inProgressUploads[file_id];

                // Armazenar chunk
                upload.chunks[chunk_index] = chunk_data;
                upload.receivedChunks += 1;

                console.log(`üì• Chunk recebido: ${filename} [${chunk_index + 1}/${total_chunks}]`);

                // Se todos os chunks foram recebidos, montar arquivo completo
                if (upload.receivedChunks === total_chunks) {
                    console.log(`‚úÖ Todos os chunks recebidos para: ${filename}`);

                    // Concatenar chunks em ordem
                    let fullData = '';
                    for (let i = 0; i < total_chunks; i++) {
                        fullData += upload.chunks[i];
                    }

                    // Armazenar arquivo completo
                    this.storeFileData(file_id, fullData, filename, mime_type);

                    // Obter metadados do arquivo (username, etc)
                    const metadata = this.fileMetadata[file_id] || {};
                    const senderUsername = metadata.username || 'Desconhecido';
                    const isOwnFile = senderUsername === this.username;

                    // S√≥ exibir se N√ÉO for arquivo pr√≥prio (arquivos pr√≥prios j√° foram exibidos no upload)
                    if (!isOwnFile) {
                        this.displayFileMessage({
                            file_id: file_id,
                            filename: filename,
                            file_size: file_size,
                            mime_type: mime_type,
                            timestamp: metadata.timestamp || Date.now(),
                            type: 'FILE_SHARE',
                            username: senderUsername
                        }, isOwnFile);
                    }

                    // Limpar upload em progresso
                    delete this.inProgressUploads[file_id];

                    console.log(`üíæ Arquivo armazenado: ${filename} (${this.formatFileSize(file_size)})`);
                }
            }

            displayMessage(message, isOwn = false) {
                const messageElement = document.createElement('div');
                messageElement.className = `message ${isOwn ? 'own' : ''} ${message.type?.toLowerCase() || 'message'}`;

                const timeStr = new Date(message.timestamp).toLocaleTimeString('pt-BR', {
                    hour: '2-digit',
                    minute: '2-digit'
                });

                messageElement.innerHTML = `
                    <div class="message-header">
                        <strong>${message.username}</strong> - ${timeStr}
                    </div>
                    <div class="message-content">
                        ${this.formatMessageContent(message.content)}
                    </div>
                `;

                this.messagesContainer.appendChild(messageElement);
                this.scrollToBottom();
            }

            displayFileMessage(message, isOwn = false) {
                const messageElement = document.createElement('div');
                messageElement.className = `message ${isOwn ? 'own' : ''}`;

                const timeStr = new Date(message.timestamp).toLocaleTimeString('pt-BR', {
                    hour: '2-digit',
                    minute: '2-digit'
                });

                const fileSize = this.formatFileSize(message.file_size);
                const fileId = message.file_id;
                const isImage = this.isImageFile(message.filename, message.mime_type);

                let contentHtml = `
                    <div class="message-header">
                        <strong>${message.username}</strong> - ${timeStr}
                    </div>
                    <div class="message-content file-message ${isOwn ? 'own' : ''}">
                `;

                if (isImage) {
                    // Para imagens, exibir diretamente
                    if (this.fileStorage.has(fileId)) {
                        const file = this.fileStorage.get(fileId);
                        const url = URL.createObjectURL(file.blob);
                        contentHtml += `
                            <img class="image-thumbnail" src="${url}" alt="${this.escapeHtml(message.filename)}" 
                                 onclick="window.chatApp.openImagePreview('${fileId}', '${this.escapeHtml(message.filename)}')">
                            <div style="font-size: 0.85rem; margin-top: 8px; opacity: 0.8;">${this.escapeHtml(message.filename)}</div>
                            <div style="font-size: 0.8rem; opacity: 0.7;">${fileSize}</div>
                        `;
                    } else {
                        contentHtml += `
                            <div class="file-info" style="color: #999;">
                                üñºÔ∏è <span class="file-name">${this.escapeHtml(message.filename)}</span>
                            </div>
                            <div style="font-size: 0.85rem; color: #999; font-style: italic; margin-top: 8px;">Imagem n√£o existe mais</div>
                        `;
                    }
                } else {
                    // Para outros arquivos, bot√£o de download
                    contentHtml += `
                        <div class="file-info">
                            üìé <span class="file-name">${this.escapeHtml(message.filename)}</span>
                        </div>
                        <div class="file-size">${fileSize}</div>
                        <button class="file-action" onclick="window.chatApp.downloadFile('${fileId}', '${this.escapeHtml(message.filename)}')">‚¨áÔ∏è Download</button>
                    `;
                }

                contentHtml += `
                    </div>
                `;

                messageElement.innerHTML = contentHtml;
                this.messagesContainer.appendChild(messageElement);
                this.scrollToBottom();
            }

            displaySystemMessage(message) {
                const messageElement = document.createElement('div');
                messageElement.className = 'message system';

                const timeStr = new Date(message.timestamp).toLocaleTimeString('pt-BR', {
                    hour: '2-digit',
                    minute: '2-digit'
                });

                messageElement.innerHTML = `
                    <div class="message-header">Sistema - ${timeStr}</div>
                    <div class="message-content">
                        ${this.formatMessageContent(message.content)}
                    </div>
                `;

                this.messagesContainer.appendChild(messageElement);
                this.scrollToBottom();
            }

            handleUserJoin(message) {
                this.onlineUsers.add(message.username);
                this.displayMessage({
                    ...message,
                    type: 'join'
                });
                this.updateUsersDisplay();
            }

            handleUserLeave(message) {
                this.onlineUsers.delete(message.username);
                this.displayMessage({
                    ...message,
                    type: 'leave'
                });
                this.updateUsersDisplay();
            }

            handleTypingStart(message) {
                if (message.username !== this.username) {
                    this.showTypingIndicator(`${message.username} est√° digitando...`);
                }
            }

            handleTypingStop(message) {
                if (message.username !== this.username) {
                    this.hideTypingIndicator();
                }
            }

            updateOnlineUsers(users) {
                this.onlineUsers.clear();
                users.forEach(user => {
                    this.onlineUsers.add(user.username);
                });
                this.updateUsersDisplay();
            }

            updateUsersDisplay() {
                const userCount = this.onlineUsers.size;
                const usersArray = Array.from(this.onlineUsers);

                this.usersList.textContent = userCount > 0
                    ? `${userCount} usu√°rio${userCount > 1 ? 's' : ''}: ${usersArray.join(', ')}`
                    : 'Nenhum usu√°rio online';
            }

            showTypingIndicator(text) {
                this.typingText.textContent = text;
                this.typingIndicator.classList.remove('hidden');
            }

            hideTypingIndicator() {
                this.typingIndicator.classList.add('hidden');
            }

            formatMessageContent(content) {
                // Escapar HTML e processar emojis
                return content
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;')
                    .replace(/\n/g, '<br>');
            }

            escapeHtml(text) {
                const map = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                };
                return text.replace(/[&<>"']/g, m => map[m]);
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
            }

            async handleFileSelect() {
                const file = this.fileInput.files[0];
                if (!file) return;

                // Validar tamanho (25MB m√°ximo)
                const maxSize = 25 * 1024 * 1024;
                if (file.size > maxSize) {
                    alert(`Arquivo muito grande! M√°ximo: ${this.formatFileSize(maxSize)}`);
                    this.fileInput.value = '';
                    return;
                }

                console.log(`üìé Arquivo selecionado: ${file.name} (${this.formatFileSize(file.size)})`);

                // Mostrar indicador de progresso
                this.uploadProgress.classList.add('visible');
                this.uploadButton.disabled = true;

                try {
                    await this.uploadFile(file);
                } catch (error) {
                    console.error('Erro ao fazer upload:', error);
                    alert('Erro ao enviar arquivo: ' + error.message);
                } finally {
                    this.fileInput.value = '';
                    this.uploadButton.disabled = false;
                    setTimeout(() => {
                        this.uploadProgress.classList.remove('visible');
                    }, 2000);
                }
            }

            async uploadFile(file) {
                const fileId = this.generateFileId();
                const chunkSize = 1024 * 1024; // 1MB chunks
                const totalChunks = Math.ceil(file.size / chunkSize);

                console.log(`üöÄ Iniciando upload: ${totalChunks} chunks`);

                for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
                    const start = chunkIndex * chunkSize;
                    const end = Math.min(start + chunkSize, file.size);
                    const chunk = file.slice(start, end);

                    // Converter chunk para base64 para enviar via WebSocket
                    const base64Chunk = await this.readFileAsBase64(chunk);

                    const fileMessage = {
                        type: 'FILE_CHUNK',
                        file_id: fileId,
                        filename: file.name,
                        mime_type: file.type,
                        chunk_index: chunkIndex,
                        total_chunks: totalChunks,
                        file_size: file.size,
                        chunk_data: base64Chunk,
                        timestamp: Date.now()
                    };

                    this.websocket.send(JSON.stringify(fileMessage));

                    // Atualizar progress bar
                    const progress = Math.round(((chunkIndex + 1) / totalChunks) * 100);
                    this.updateUploadProgress(progress);

                    console.log(`üì§ Chunk ${chunkIndex + 1}/${totalChunks} enviado`);

                    // Pequena pausa entre chunks para evitar sobrecarregar
                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                console.log(`‚úÖ Upload conclu√≠do: ${file.name}`);

                // Ler arquivo completo para armazenar localmente
                const fullData = await this.readFileAsBase64(file);
                this.storeFileData(fileId, fullData, file.name, file.type);

                // Enviar notifica√ß√£o de conclus√£o
                const completeMessage = {
                    type: 'FILE_SHARE',
                    file_id: fileId,
                    filename: file.name,
                    mime_type: file.type,
                    file_size: file.size,
                    timestamp: Date.now()
                };

                this.websocket.send(JSON.stringify(completeMessage));

                // Exibir arquivo localmente
                this.displayFileMessage({
                    file_id: fileId,
                    filename: file.name,
                    file_size: file.size,
                    username: this.username,
                    timestamp: Date.now(),
                    type: 'FILE_SHARE',
                    mime_type: file.type
                }, true);
            }

            readFileAsBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        // Remover o prefixo "data:...;base64,"
                        const base64 = reader.result.split(',')[1];
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            generateFileId() {
                return `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }

            updateUploadProgress(percentage) {
                this.uploadProgressFill.style.width = percentage + '%';
                this.uploadProgressText.textContent = percentage + '%';
            }

            downloadFile(fileId, filename) {
                console.log(`‚¨áÔ∏è Iniciando download: ${filename} (${fileId})`);

                // Verificar se arquivo est√° armazenado localmente
                if (this.fileStorage.has(fileId)) {
                    const file = this.fileStorage.get(fileId);
                    this.downloadBlob(file.blob, filename);
                    return;
                }

                // Se n√£o estiver em cache, enviar requisi√ß√£o para o servidor
                const downloadMessage = {
                    type: 'FILE_DOWNLOAD_REQUEST',
                    file_id: fileId,
                    filename: filename,
                    timestamp: Date.now()
                };

                this.websocket.send(JSON.stringify(downloadMessage));
                console.log(`üì• Requisi√ß√£o de download enviada para: ${filename}`);
            }

            isImageFile(filename, mimeType) {
                const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg'];
                const imageTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/bmp', 'image/webp', 'image/svg+xml'];

                const ext = filename.split('.').pop()?.toLowerCase() || '';

                return imageExtensions.includes(ext) || imageTypes.includes(mimeType?.toLowerCase());
            }

            openImagePreview(fileId, filename) {
                console.log(`üîç Abrindo preview: ${filename} (${fileId})`);

                // Verificar se arquivo est√° armazenado localmente
                if (this.fileStorage.has(fileId)) {
                    const file = this.fileStorage.get(fileId);
                    const url = URL.createObjectURL(file.blob);

                    this.modalImage.src = url;
                    this.modalTitle.textContent = filename;
                    this.currentPreviewFile = {
                        blob: file.blob,
                        filename: filename,
                        url: url
                    };

                    this.previewModal.classList.add('visible');
                } else {
                    alert('Arquivo n√£o encontrado. Aguarde o download completar.');
                }
            }

            closePreviewModal() {
                this.previewModal.classList.remove('visible');

                // Limpar object URL
                if (this.currentPreviewFile && this.currentPreviewFile.url) {
                    URL.revokeObjectURL(this.currentPreviewFile.url);
                }
                this.currentPreviewFile = null;
            }

            downloadCurrentFile() {
                if (this.currentPreviewFile) {
                    this.downloadBlob(this.currentPreviewFile.blob, this.currentPreviewFile.filename);
                }
            }

            downloadBlob(blob, filename) {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                // Limpar object URL ap√≥s download
                setTimeout(() => URL.revokeObjectURL(url), 100);
            }

            storeFileData(fileId, data, filename, mimeType) {
                try {
                    // Decodificar base64 e criar blob
                    const binaryString = atob(data);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }

                    const blob = new Blob([bytes], { type: mimeType });

                    // Armazenar na mem√≥ria
                    this.fileStorage.set(fileId, {
                        blob: blob,
                        filename: filename,
                        mimeType: mimeType,
                        size: blob.size,
                        storedAt: Date.now()
                    });

                    console.log(`‚úÖ Arquivo armazenado: ${filename} (${this.formatFileSize(blob.size)})`);

                    // Limitar tamanho do cache (manter apenas √∫ltimos 10 arquivos ou 100MB)
                    this.cleanFileCache();
                } catch (error) {
                    console.error(`‚ùå Erro ao armazenar arquivo: ${error.message}`);
                }
            }

            cleanFileCache() {
                // Manter apenas √∫ltimos 10 arquivos em cache
                if (this.fileStorage.size > 10) {
                    const entries = Array.from(this.fileStorage.entries());
                    const sorted = entries.sort((a, b) =>
                        (b[1].storedAt || 0) - (a[1].storedAt || 0)
                    );

                    // Remover os mais antigos
                    for (let i = 10; i < sorted.length; i++) {
                        this.fileStorage.delete(sorted[i][0]);
                    }
                }
            }

            sendMessage() {
                const content = this.messageInput.value.trim();

                if (!content || !this.isConnected) {
                    return;
                }

                const message = {
                    type: 'MESSAGE',
                    content: content,
                    timestamp: Date.now()
                };

                try {
                    this.websocket.send(JSON.stringify(message));

                    // Exibir mensagem pr√≥pria imediatamente
                    this.displayMessage({
                        message_id: `local_${Date.now()}`,
                        user_id: 'me',
                        username: this.username,
                        content: content,
                        timestamp: Date.now(),
                        type: 'MESSAGE',
                        room_id: this.roomId
                    }, true);

                    this.messageInput.value = '';
                    this.stopTyping();
                } catch (error) {
                    console.error('Erro ao enviar mensagem:', error);
                }
            }

            handleTyping() {
                if (!this.isConnected) return;

                if (!this.isTyping) {
                    this.isTyping = true;
                    this.sendTypingNotification('TYPING_START');
                }

                clearTimeout(this.typingTimer);
                this.typingTimer = setTimeout(() => {
                    this.stopTyping();
                }, 2000);
            }

            stopTyping() {
                if (this.isTyping) {
                    this.isTyping = false;
                    this.sendTypingNotification('TYPING_STOP');
                }
                clearTimeout(this.typingTimer);
            }

            sendTypingNotification(type) {
                if (!this.isConnected) return;

                try {
                    this.websocket.send(JSON.stringify({
                        type: type,
                        content: '',
                        timestamp: Date.now()
                    }));
                } catch (error) {
                    console.error('Erro ao enviar notifica√ß√£o de digita√ß√£o:', error);
                }
            }

            scrollToBottom() {
                this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
            }

            showLoginError(message) {
                this.loginError.textContent = message;
                this.loginError.classList.remove('hidden');

                setTimeout(() => {
                    this.loginError.classList.add('hidden');
                }, 5000);
            }

            disconnect() {
                if (this.websocket) {
                    this.websocket.close(1000, 'User disconnecting');
                }
            }
        }

        // Fun√ß√£o global para adicionar emojis
        function addEmoji(emoji) {
            const messageInput = document.getElementById('messageInput');
            messageInput.value += emoji;
            messageInput.focus();
        }

        // Inicializar aplica√ß√£o quando a p√°gina carregar
        document.addEventListener('DOMContentLoaded', () => {
            window.chatApp = new ChatApp();
        });
    </script>
</body>

</html>